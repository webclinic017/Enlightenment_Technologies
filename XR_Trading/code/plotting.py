from utilities import accuracy, round_sig, calculate_L_scoresimport matplotlib.pyplot as pltimport pandas as pdimport numpy as npfrom sklearn.metrics import r2_scorepd.options.mode.chained_assignment = Nonedef plot_residuals(observed, predicted):        vector_len = len(observed)    x_axis =  np.zeros((vector_len, 1))    residual_vector =  np.zeros((vector_len, 1))        observed = observed.to_numpy()    predicted = predicted.to_numpy()        for i in range(0,vector_len):        x_axis[i] = i        residual_vector[i] =  (observed[i] - predicted[i])/observed[i]            plt.figure(figsize=(7,5))    plt.plot(x_axis, residual_vector, label = r'$\frac{Observed_i - Predicted_i}{Observed_i}$')    plt.title('Residuals')    plt.xlabel('Number of Predictions on Provided Data', fontsize=8)    plt.legend()    plt.show()def visualize_fit(data_target, training_data_len, multiple_predictions, prediction_num, model_label, plot_other_predictions):        L1_Distance, L2_Distance = calculate_L_scores(data_target, training_data_len, multiple_predictions, prediction_num)        # Visualising the results    train = data_target.head(training_data_len)    valid = data_target.tail(len(data_target)-training_data_len)    prediction_average = np.zeros(multiple_predictions.shape[0])        for i in range(0, prediction_num):                prediction_lable = 'Prediction_' + str(i)         valid[prediction_lable] = multiple_predictions[:,i]        prediction_average += multiple_predictions[:,i]            valid['Prediction Average'] = prediction_average/prediction_num        # Plot Residuals    plot_residuals(valid['so2'], valid['Prediction Average'])        # Accuracy Score    for i in range(0, prediction_num):                prediction_lable = 'Prediction_' + str(i)        L1_Distance, L2_Distance = accuracy(valid[['so2']], valid[[prediction_lable]])                L1_Distance += L1_Distance        L2_Distance += L2_Distance        L1_Distance, L2_Distance = L1_Distance/prediction_num, L2_Distance/prediction_num    L1_Distance, L2_Distance = round_sig(L1_Distance), round_sig(L2_Distance)        L1_Distance_Label = 'L1 Average Distance: ' + str(L1_Distance)    L2_Distance_Label = 'L2 Average Distance: ' + str(L2_Distance)        print('\n' + L1_Distance_Label)    print('\n' + L2_Distance_Label)    # Plotting    plt.figure(figsize=(10,5))    plt.title(model_label +' Model Forcasting for ')    plt.xlabel('Days Since Feb 1st', fontsize=12)    plt.ylabel('SO2 Levels', fontsize=12)    plt.plot(train['so2'], label = 'Train')    plt.plot(valid['so2'], label = 'Test')    plt.legend(['Train', 'Test'], loc='upper left')        if plot_other_predictions == True:            for i in range(0, prediction_num):                    prediction_lable = 'Prediction_' + str(i)            plt.plot(valid[[prediction_lable]], alpha=0.25)                plt.plot(valid['Prediction Average'], label = 'Average Prediction ' + r'$R^2$ = {}'.format(round_sig(r2_score(valid['so2'].to_numpy(), valid['Prediction Average'].to_numpy()))))    #plt.legend(['Average Prediction' + r'$L_1$ = {}'.format(L1_Distance) + r', $L_2$ = {}'.format(L2_Distance)], loc='upper left')    plt.legend(['Average Prediction' + r'$R^2$ = {}'.format(r2_score(valid['so2'].to_numpy(), valid['Prediction Average'].to_numpy()))], loc='upper left')    plt.legend(loc='upper left')    plt.show()    # Utility function for plotting of the model resultsdef visualize_loss(loss, prediction_num, model_label):      # Plot the accuracy and loss curves    epochs = range(len(loss))        plt.figure(figsize=(7,5))        for i in range(0, prediction_num):            plt.plot(epochs, loss[:,i], label=str(i))        plt.title(model_label + ' Training Loss')    plt.legend()    plt.show()        def visualize_val_loss(val_loss, prediction_num, model_label):    # Plot the accuracy and loss curves    epochs = range(len(val_loss))        plt.figure(figsize=(7,5))        for i in range(0, prediction_num):            plt.plot(epochs, val_loss[:,i], label=str(i))        plt.title(model_label + ' Validation Loss')    plt.legend()    plt.show()    def plot_data(dataset):    values = dataset.values    num_columns = len(dataset.columns)    plt.figure(figsize=(14,6))        for i in range(0, num_columns):            	plt.subplot(num_columns, 1, i+1)    	plt.plot(values[:, i])    	plt.title(dataset.columns[i], y=0.5, loc='right')    plt.show()                                                                                                